#!/usr/bin/env ruby

require 'curses'
require 'socket'
require 'optparse'

class Scrollbar
  UP_ARROW   = '▴'
  DOWN_ARROW = '▾'

  attr_reader :list

  def width
    1
  end

  def initialize(list)
    @list = list
    @color_background = 4
    Curses.init_pair(@color_background, Curses::COLOR_BLACK, Curses::COLOR_BLACK)

    @color_thumb = 5
    Curses.init_pair(@color_thumb, Curses::COLOR_WHITE, Curses::COLOR_WHITE)

    @color_arrow = 6
    Curses.init_pair(@color_arrow, Curses::COLOR_WHITE, Curses::COLOR_BLACK)
  end

  def scroll_thumb_range
    # Ref: http://csdgn.org/inform/scrollbar-mechanics
    #  using original variableNames for clarity.
    contentSize = list.values.size.to_f
    windowSize = window.maxy.to_f
    trackSize = windowSize - 2
    windowContentRatio = windowSize / contentSize
    gripSize = trackSize * windowContentRatio

    minimalGripSize = 1.0
    if(gripSize < minimalGripSize)
      gripSize = minimalGripSize
    end

    windowScrollAreaSize = contentSize - windowSize
    windowPosition = list.offset.to_f
    windowPositionRatio = windowPosition / windowScrollAreaSize

    trackScrollAreaSize = trackSize - gripSize
    gripPositionOnTrack = trackScrollAreaSize * windowPositionRatio


    st = 1 + gripPositionOnTrack.floor.to_i
    e = (st + gripSize.ceil).to_i

    st = 1 if st < 1
    e = window.maxy - 1 if e > window.maxy - 1

    @last ||= []
    if @last != [st,e]
      list.socket.puts [st, e].inspect
      @last = [st, e]
    end

    return st...e
  end

  def render
    x = window.maxx - self.width

    return if list.values.size <= window.maxy

    window.color_set(@color_arrow)
    window.setpos(0, x)
    window.addstr(UP_ARROW)

    window.setpos(window.maxy - 1, x)
    window.addstr(DOWN_ARROW)

    window.color_set(@color_background)
    (1...window.maxy - 1).each do |y|
      window.setpos(y, x)
      window.addstr(' ')
    end

    window.color_set(@color_thumb)
    scroll_thumb_range.each do |y|
      window.setpos(y, x)
      window.addstr(' ')
    end
  end

  def window
    list.window
  end

  def can_scroll_up?
    list.offset > 0
  end

  def can_scroll_down?
    list.values.size > list.offset + window.maxy
  end
end

class List
  INDICATOR    = ' ➤ '
  NO_INDICATOR = '   '

  attr_reader   :window
  attr_reader   :socket
  attr_accessor :values
  attr_reader   :selected
  attr_reader   :offset

  attr_reader :color_default
  attr_reader :color_selected
  attr_reader :scrollbar

  def initialize(window, socket:)
    @window = window
    @values = []
    @selected = 0
    @offset = 0
    @socket = socket
    @dirty = true
    @locked = false

    @color_default  = 0
    @color_selected = 1
    Curses.init_pair(@color_default, Curses::COLOR_WHITE, Curses::COLOR_BLACK)
    Curses.init_pair(@color_selected, Curses::COLOR_BLACK, Curses::COLOR_WHITE)

    @scrollbar = Scrollbar.new(self)
  end

  def lock
    @locked = true
    yield
  ensure
    @locked = false
    render
  end

  def locked?
    @locked
  end

  def dirty!
    @dirty = true
  end

  def dirty?
    !! @dirty
  end

  def offset=(v)
    dirty! if v != @offset
    @offset = v
  end

  attr_reader :selected
  def selected=(v)
    current = @selected

    v = 0 if v < 0
    v = values.size - 1 if v >= values.size
    @selected = v

    if @selected >= offset + window.maxy
      self.offset = v - window.maxy + 1
    elsif @selected < offset
      self.offset = @selected
    end

    if current != selected
      dirty!
      selection_changed
    end
    @selected
  end

  def key_name(v)
    @m ||= {
      10  => 'enter',
      260 => 'left',
      261 => 'right',
      127 => 'backspace',
      330 => 'delete',
      ' ' => 'space',
    }
    @m[v] || v
  end

  def handle_input(value)
    case value
      when Curses::KEY_RESIZE
        window.clear
        dirty!
        render
      when Curses::KEY_UP
        self.selected -= 1
      when Curses::KEY_DOWN
        self.selected += 1
      when Curses::KEY_PPAGE
        self.selected -= window.maxy - 1
      when Curses::KEY_NPAGE
        self.selected += window.maxy - 1
      else
        key_pressed(value)
    end
  end

  def selection_changed
    socket.puts "select #{selected} #{values[selected]}"
  end

  def key_pressed(k)
    socket.puts "keypress #{key_name(k)} #{selected} #{values[selected]}"
  end

  def dirty!(v = true)
    @dirty = v
  end

  def normalize(s)
    return s.gsub(/[^[:print:]]/, '').chomp
      .each_char.map.with_index do |c, i|
        if c == "\t"
          next_stop = i + (8 - i % 8)
          ' ' * (next_stop - i)
        else
          c
        end
      end.join
  end


  def render()
    return if locked?
    return unless dirty?
    dirty!(false)

    (0...window.maxy).each do |i|
      item_index = @offset + i
      window.setpos(i, 0)
      indicator = nil

      fixed_len = window.maxx - scrollbar.width - 1

      if item_index == selected
        window.color_set(@color_selected)
        indicator = INDICATOR
      else
        window.color_set(@color_default)
        indicator = NO_INDICATOR
      end

      string = values[item_index] || ''
      string = normalize(string)
      string = indicator + string

      if string.size < fixed_len
        string += (' ' * (fixed_len - string.size))
      elsif string.size > fixed_len
        string = string[0...fixed_len]
      end

      window.addstr(string)
    end

    scrollbar.render
  end
end

class ClientTerminal
  attr_accessor :list
  def initialize(socket)
    Curses.init_screen
    Curses.start_color
    Curses.use_default_colors
    Curses.cbreak
    Curses.stdscr.scrollok(false)
    Curses.stdscr.keypad = true
    Curses.curs_set(0)
    Curses.noecho
    Curses.timeout = 0

    @socket = socket
    @list = List.new(Curses.stdscr, socket: @socket)
    @list.values = []
    @buffer = ''
  end

  def process_command(cmd)
    list.values.push(cmd)
    list.dirty!
  end

  def process_buffer
    @list.lock do
      # This select needs to be a small interval to make ncurses
      # blocking getch responsive.
      res = IO.select([@socket], [], [], 0.0001)
      if res && (readers = res[0]) && (rd = readers[0])
        loop do
          begin
            @buffer << rd.read_nonblock(512)
          rescue IO::WaitReadable
            break
          end
        end
      end

      used = 0
      StringIO.new(@buffer).each_line do |line|
        if line[-1] == "\n"
          process_command(line.chomp)
          used += line.size
        else
          break
        end
      end
      @buffer = @buffer[used...-1]
    end
  end

  def run
    begin
      loop do
        process_buffer
        list.render
        if (ch = Curses.getch)
          list.handle_input(ch)
        end
        Curses.refresh
      end
    ensure
      Curses.close_screen
    end
  end
end


STDIN.sync = true
STDOUT.sync = true

com = UNIXSocket.pair
com.map {|c| c.sync=true }

child = fork do
  # All of this fd fiddling stuff is because Ruby curses doesn't expose
  # newterm()
  STDIN.reopen('/dev/tty', 'r')
  STDOUT.reopen('/dev/tty', 'w')

  gui = ClientTerminal.new(com[1])
  begin
    gui.run
  rescue Interrupt
  end
  exit 0
end


if STDOUT.tty?
  STDOUT.reopen('/dev/null', 'w')
end
STDOUT.sync = true

if STDIN.tty?
  STDIN.reopen('/dev/null', 'r')
end
STDIN.sync = true

gui_socket = com[0]
lines = {
  $stdin    => nil,
  gui_socket => nil
}

bufs = {
  $stdin => '',
  gui_socket => ''
}

handles = [$stdin, gui_socket]

@gui_socket = gui_socket
def dispatch_input_command(command)
  @gui_socket.puts command
end

def dispatch_line(fd, line)
  if fd == $stdin
    dispatch_input_command(line)
  else # coming from the subprocess
    puts line
  end
end


loop do
  res = IO.select(handles, [], [], 0.25)

  if res && (rd = res[0])
    rd.each do |fd|
      loop do
        begin
          bytes = fd.read_nonblock(512)
          bufs[fd] << bytes
        rescue EOFError
          handles.delete(fd)
          break
        rescue IO::WaitReadable
          break
        end
      end
    end
  end

  bufs.each do |fd, str|
    used = 0
    sio = StringIO.new(str)
    sio.each_line do |line|
      if line[-1] == "\n"
        used += line.size
        dispatch_line(fd, line.chomp)
      else
        break
      end
    end
    bufs[fd] = str[used...-1]
  end
  bufs.reject! {|fd, v| fd.eof? }
end
