#!/usr/bin/env ruby

require 'ncurses'
require 'shellwords'
require 'optparse'

class Scrollbar
  UP_ARROW   = '▴'
  DOWN_ARROW = '▾'

  def width
    1
  end

  attr_reader :list

  def initialize(list)
    @list = list

    @color_background = 4
    Ncurses.init_pair(@color_background, Ncurses::COLOR_BLACK,
                                         Ncurses::COLOR_BLACK)

    @color_thumb = 5
    Ncurses.init_pair(@color_thumb, Ncurses::COLOR_WHITE,
                                    Ncurses::COLOR_WHITE)

    @color_arrow = 6
    Ncurses.init_pair(@color_arrow, Ncurses::COLOR_WHITE,
                                    Ncurses::COLOR_BLACK)
  end

  def scroll_thumb_range
    maxx, maxy = getmaxxy

    # Ref: http://csdgn.org/inform/scrollbar-mechanics
    #  using original variableNames for clarity.
    contentSize = list.values.size.to_f
    windowSize = maxy.to_f
    trackSize = windowSize - 2
    windowContentRatio = windowSize / contentSize
    gripSize = trackSize * windowContentRatio

    minimalGripSize = 1.0
    if gripSize < minimalGripSize
      gripSize = minimalGripSize
    end

    windowScrollAreaSize = contentSize - windowSize
    windowPosition = list.offset.to_f
    windowPositionRatio = windowPosition / windowScrollAreaSize

    trackScrollAreaSize = trackSize - gripSize
    gripPositionOnTrack = trackScrollAreaSize * windowPositionRatio

    st = 1 + gripPositionOnTrack.floor.to_i
    e = (st + gripSize.ceil).to_i

    st = 1 if st < 1
    e = maxy - 1 if e > maxy - 1

    return st...e
  end

  def window
    list.window
  end

  def getmaxxy
    list.getmaxxy
  end

  def render
    maxx, maxy = getmaxxy

    x = maxx - self.width

    return if list.values.size <= maxy

    window.color_set(@color_arrow, nil)
    window.move(0, x)
    window.addstr(UP_ARROW)

    window.move(maxy - 1, x)
    window.addstr(DOWN_ARROW)

    window.color_set(@color_background, nil)
    (1...maxy - 1).each do |y|
      window.move(y, x)
      window.addstr(' ')
    end

    window.color_set(@color_thumb, nil)
    scroll_thumb_range.each do |y|
      window.move(y, x)
      window.addstr(' ')
    end
  end

  def can_scroll_up?
    list.offset > 0
  end

  def can_scroll_down?
    maxx, maxy = getmaxxy
    list.values.size > list.offset + maxy
  end
end


class List
  INDICATOR    = ' ➤ '
  NO_INDICATOR = '   '

  attr_reader   :window
  attr_accessor :values
  attr_reader   :selected
  attr_reader   :offset

  attr_reader :color_default
  attr_reader :color_selected
  attr_reader :scrollbar

  def initialize(window)
    @window = window
    @values = []
    @selected = 0
    @offset = 0
    @dirty = true
    @locked = false

    @color_default  = 0
    @color_selected = 1
    Ncurses.init_pair(@color_default, Ncurses::COLOR_WHITE, Ncurses::COLOR_BLACK)
    Ncurses.init_pair(@color_selected, Ncurses::COLOR_BLACK, Ncurses::COLOR_WHITE)

    @scrollbar = Scrollbar.new(self)
  end

  def locked
    fail ArgumentError, "block required" unless block_given?
    @locked = true
    yield
  ensure
    @locked = false
    render
  end

  def locked?
    @locked
  end

  def dirty!(value = true)
    @dirty = value
  end

  def dirty?
    !! @dirty
  end

  def offset=(v)
    dirty! if v != @offset
    @offset = v
  end

  attr_reader :selected
  def selected=(v)
    maxx, maxy = getmaxxy
    current = @selected

    v = 0 if v < 0
    v = values.size - 1 if v >= values.size
    @selected = v

    if @selected >= offset + maxy
      self.offset = v - maxy + 1
    elsif @selected < offset
      self.offset = @selected
    end

    if current != @selected
      dirty!
      selection_changed
    end

    @selected
  end

  def key_name(v)
    @m ||= {
      10  => 'enter',
      260 => 'left',
      261 => 'right',
      127 => 'backspace',
      330 => 'delete',
      ' ' => 'space',
    }
    @m[v] || v
  end

  def handle_input(value)
    maxx, maxy = getmaxxy

    case value
      when -1
        return
      when Ncurses::KEY_RESIZE
        window.clear
        dirty!
      when Ncurses::KEY_UP
        self.selected -= 1
      when Ncurses::KEY_DOWN
        self.selected += 1
      when Ncurses::KEY_PPAGE
        self.selected -= maxy - 1
      when Ncurses::KEY_NPAGE
        self.selected += maxy - 1
      else
        key_pressed(value)
    end
  end

  def selection_changed
    puts "select #{selected} #{values[selected]}"
  end

  def key_pressed(k)
    puts "keypress #{key_name(k)} #{selected} #{values[selected]}"
  end

  def dirty!(v = true)
    @dirty = v
  end

  def normalize(s)
    return s.gsub(/[^[:print:]]/, '')
            .chomp
            .each_char.map.with_index do |c, i|
              if c == "\t"
                next_stop = i + (8 - i % 8)
                ' ' * (next_stop - i)
              else
                c
              end
            end.join
  end

  def getmaxxy
    maxx, maxy = [], []
    window.getmaxyx(maxy, maxx)
    [maxx.first, maxy.first]
  end

  def render()
    return if locked?
    return unless dirty?
    dirty!(false)

    maxx, maxy = getmaxxy

    (0...maxy).each do |i|
      item_index = offset + i
      window.move(i, 0)
      indicator = nil

      fixed_len = maxx - scrollbar.width - 1

      if item_index == selected
        window.color_set(color_selected, nil)
        indicator = INDICATOR
      else
        window.color_set(color_default, nil)
        indicator = NO_INDICATOR
      end

      string = values[item_index] || ''
      string = normalize(string)
      string = indicator + string

      if string.size < fixed_len
        string += (' ' * (fixed_len - string.size))
      elsif string.size > fixed_len
        string = string[0...fixed_len]
      end
      window.addstr(string)
    end

    scrollbar.render
  end
end


class ClientTerminal
  attr_reader :list
  attr_reader :mode

  def initialize
    @mode = :append

    @tty = File.open('/dev/tty', 'r+')
    @tty.sync = true
    screen = Ncurses.newterm(nil, @tty, @tty)
    Ncurses.set_term(screen)
    Ncurses.start_color
    Ncurses.use_default_colors
    Ncurses.cbreak
    Ncurses.stdscr.scrollok(false)
    Ncurses.stdscr.keypad(true)
    Ncurses.curs_set(0)
    Ncurses.noecho
    Ncurses.timeout(0)

    @list = List.new(Ncurses.stdscr)
    @buffer = ''
  end

  def deinitialize
    Ncurses.echo
    Ncurses.nocbreak
    Ncurses.nl
    Ncurses.endwin
    @tty.close
  end

  def append_mode?
    @mode == :append
  end

  def process_command(line)
    if append_mode?
      case line
      when '\%%'
        list.values.push('%%')
        list.dirty!
      when '%%'
        @mode = :command
      else
        list.values.push(line)
        list.dirty!
      end
    else
      cmd, *args = Shellwords.split(line)
      begin
        case cmd
          when 'append-mode'
            @mode = :append
          when 'get-selected'
            list.selection_changed
          when 'select'
            list.selected = args.fetch(0).to_i
          when 'get-item'
            puts ["item", args.fetch(0), list.values[args.fetch(0).to_i]].join ' '
          when 'quit'
            raise Interrupt
        end
      rescue IndexError => e
        $stderr.puts "#{0}: bad command: #{line}"
        $stderr.puts "#  #{e.message}"
      end
    end

  end

  def process_buffer
    @handles ||= [$stdin]

    return if @handles.empty? && @buffer.empty?

    @list.locked do
      unless @handles.empty?
        # This select needs to be a small interval to make ncurses
        # blocking getch responsive.
        res = IO.select(@handles, [], [], 0.0001)
        if res && res[0]
          loop do
            begin
              @buffer << $stdin.read_nonblock(512)
            rescue EOFError
              @handles = []
              break
            rescue IO::WaitReadable
              break
            end
          end
        end
      end

      unless @buffer.empty?
        used = 0
        StringIO.new(@buffer).each_line do |line|
          if line[-1] == "\n"
            process_command(line.chomp)
            used += line.size
          else
            break
          end
        end
        @buffer = @buffer[used...-1]
      end
    end
  end

  def run
    begin
      loop do
        process_buffer
        while (ch = Ncurses.getch) != -1
          list.handle_input(ch)
        end
        list.render
        Ncurses.refresh
      end
    ensure
      deinitialize
    end
  end
end

[$stdin, $stdout].each do |io|
  io.sync = true
  io.reopen('/dev/null') if io.tty?
end


begin
  ClientTerminal.new.run
rescue Interrupt
  # nothing.
rescue SystemCallError => e
  $stderr.puts "#{$0}: #{e.message}"
  exit 1
end
