#!/usr/bin/env ruby

require 'ncurses'
require 'shellwords'
require 'optparse'

# This file is larger than I like because I want to keep it self-contained.
# That is: assuming all the dependencies are met, it can just be copied to
# /usr/local/bin or dropped in your program's source directory and work without
# a gem/bundle/etc step.  Otherwise, we attempt to follow good practices.

class Color
  VALUES = {
    list_default: 0,
    list_selected: 1,
    scroll_track: 2,
    scroll_thumb: 3,
    scroll_arrow: 4,
  }.freeze

  def self.curses_lookup(c)
    Ncurses.const_get(c)
  end

  def self.init_color(c, fg, bg)
    fail "Invalid color: #{c.inspect}" if VALUES[c].nil?
    Ncurses.init_pair(VALUES[c], curses_lookup(fg), curses_lookup(bg))
  end

  def self.init
    init_color(:list_selected, :COLOR_BLACK, :COLOR_WHITE)
    init_color(:scroll_track, :COLOR_BLACK, :COLOR_BLACK)
    init_color(:scroll_thumb, :COLOR_WHITE, :COLOR_WHITE)
    init_color(:scroll_arrow, :COLOR_WHITE, :COLOR_BLACK)
  end

  def self.[](name)
    VALUES[name] or fail "invalid color name: #{name.inspect}"
  end
end

class Scrollbar
  UP_ARROW   = '▴'
  DOWN_ARROW = '▾'

  def width
    1
  end

  attr_reader :list

  def initialize(list)
    @list = list
  end

  def scroll_thumb_range
    maxx, maxy = getmaxxy

    # Ref: http://csdgn.org/inform/scrollbar-mechanics
    #  using original variableNames for clarity.
    contentSize = list.values.size.to_f
    windowSize = maxy.to_f
    trackSize = windowSize - 2
    windowContentRatio = windowSize / contentSize
    gripSize = trackSize * windowContentRatio

    minimalGripSize = 1.0
    if gripSize < minimalGripSize
      gripSize = minimalGripSize
    end

    windowScrollAreaSize = contentSize - windowSize
    windowPosition = list.offset.to_f
    windowPositionRatio = windowPosition / windowScrollAreaSize

    trackScrollAreaSize = trackSize - gripSize
    gripPositionOnTrack = trackScrollAreaSize * windowPositionRatio

    st = 1 + gripPositionOnTrack.floor.to_i
    e = (st + gripSize.ceil).to_i

    st = 1 if st < 1
    e = maxy - 1 if e > maxy - 1

    return st...e
  end

  def window
    list.window
  end

  def getmaxxy
    list.getmaxxy
  end

  def render
    maxx, maxy = getmaxxy

    x = maxx - self.width

    return if list.values.size <= maxy

    window.color_set(Color[:scroll_arrow], nil)
    window.move(0, x)
    window.addstr(UP_ARROW)

    window.move(maxy - 1, x)
    window.addstr(DOWN_ARROW)

    window.color_set(Color[:scroll_track], nil)
    (1...maxy - 1).each do |y|
      window.move(y, x)
      window.addstr(' ')
    end

    window.color_set(Color[:scroll_thumb], nil)
    scroll_thumb_range.each do |y|
      window.move(y, x)
      window.addstr(' ')
    end
  end

  def can_scroll_up?
    list.offset > 0
  end

  def can_scroll_down?
    maxx, maxy = getmaxxy
    list.values.size > list.offset + maxy
  end
end


class List
  INDICATOR    = ' ➤ '
  NO_INDICATOR = '   '

  attr_reader :window
  attr_accessor :values
  attr_reader :selected
  attr_reader :offset
  attr_reader :scrollbar

  def initialize(window)
    @window = window
    @values = []
    @selected = 0
    @offset = 0
    @dirty = true
    @locked = false
    @scrollbar = Scrollbar.new(self)
  end

  def locked
    fail ArgumentError, "block required" unless block_given?
    @locked = true
    yield
  ensure
    @locked = false
    render
  end

  def locked?
    @locked
  end

  def dirty!(value = true)
    @dirty = value
  end

  def dirty?
    !! @dirty
  end

  def offset=(v)
    dirty! if v != @offset
    @offset = v
  end

  attr_reader :selected
  def selected=(v)
    maxx, maxy = getmaxxy
    current = @selected

    v = 0 if v < 0
    v = values.size - 1 if v >= values.size
    @selected = v

    if @selected >= offset + maxy
      self.offset = v - maxy + 1
    elsif @selected < offset
      self.offset = @selected
    end

    if current != @selected
      dirty!
      selection_changed
    end

    @selected
  end

  def key_name(v)
    @m ||= {
      27  => 'esc',
      10  => 'enter',
      260 => 'left',
      261 => 'right',
      127 => 'backspace',
      330 => 'delete',
      ' ' => 'space',
    }
    @m[v] || (v < 255 && v.chr.match(/[[:print:]]/) ? v.chr : "\##{v}")
  end

  def handle_input(value)
    maxx, maxy = getmaxxy

    case value
      when -1
        return
      when Ncurses::KEY_RESIZE
        window.clear
        dirty!
      when Ncurses::KEY_UP
        self.selected -= 1
      when Ncurses::KEY_DOWN
        self.selected += 1
      when Ncurses::KEY_PPAGE
        self.selected -= maxy - 1
      when Ncurses::KEY_NPAGE
        self.selected += maxy - 1
      else
        key_pressed(value)
    end
  end

  def selection_changed
    puts "select #{selected} #{values[selected]}"
  end

  def key_pressed(k)
    puts "keypress #{key_name(k)} #{selected} #{values[selected]}"
  end

  def dirty!(v = true)
    @dirty = v
  end

  def normalize(s)
    return s.gsub(/[^[:print:]]/, '')
            .chomp
            .each_char.map.with_index do |c, i|
              if c == "\t"
                next_stop = i + (8 - i % 8)
                ' ' * (next_stop - i)
              else
                c
              end
            end.join
  end

  def getmaxxy
    maxx, maxy = [], []
    window.getmaxyx(maxy, maxx)
    [maxx.first, maxy.first]
  end

  def render()
    return if locked?
    return unless dirty?
    dirty!(false)

    maxx, maxy = getmaxxy

    (0...maxy).each do |i|
      item_index = offset + i
      window.move(i, 0)
      indicator = nil

      fixed_len = maxx - scrollbar.width - 1

      if item_index == selected
        window.color_set(Color[:list_selected], nil)
        indicator = INDICATOR
      else
        window.color_set(Color[:list_default], nil)
        indicator = NO_INDICATOR
      end

      string = values[item_index] || ''
      string = normalize(string)
      string = indicator + string

      if string.size < fixed_len
        string += (' ' * (fixed_len - string.size))
      elsif string.size > fixed_len
        string = string[0...fixed_len]
      end
      window.addstr(string)
    end

    scrollbar.render
  end
end


class ClientTerminal
  attr_reader :list
  attr_reader :mode

  def initialize
    @mode = :append

    @tty = File.open('/dev/tty', 'r+')
    @tty.sync = true
    screen = Ncurses.newterm(nil, @tty, @tty)
    Ncurses.set_term(screen)
    Ncurses.start_color
    Color.init
    Ncurses.use_default_colors
    Ncurses.cbreak
    Ncurses.stdscr.scrollok(false)
    Ncurses.stdscr.keypad(true)
    Ncurses.curs_set(0)
    Ncurses.noecho
    Ncurses.timeout(0)

    @list = List.new(Ncurses.stdscr)
    @buffer = ''
  end

  def deinitialize
    Ncurses.echo
    Ncurses.nocbreak
    Ncurses.nl
    Ncurses.endwin
    @tty.close
  end

  def append_mode?
    @mode == :append
  end

  def process_command(line)
    if append_mode?
      case line
      when '\%%'
        list.values.push('%%')
        list.dirty!
      when '%%'
        @mode = :command
      else
        list.values.push(line)
        list.dirty!
      end
    else
      cmd, *args = Shellwords.split(line)
      begin
        case cmd
          when '%%', 'append-mode'
            @mode = :append
          when 'get-selected'
            list.selection_changed
          when 'select'
            list.selected = args.fetch(0).to_i
          when 'get-item'
            puts ["item", args.fetch(0), list.values[args.fetch(0).to_i]].join ' '
          when 'quit'
            raise Interrupt
        end
      rescue IndexError => e
        puts "error bad-command #{line}"
      end
    end

  end

  def process_buffer
    @handles ||= [$stdin]

    return if @handles.empty? && @buffer.empty?

    @list.locked do
      unless @handles.empty?
        # This select needs to be a small interval to make ncurses
        # blocking getch responsive.
        res = IO.select(@handles, [], [], 0.0001)
        if res && res[0]
          loop do
            begin
              @buffer << $stdin.read_nonblock(512)
            rescue EOFError
              @handles = []
              break
            rescue IO::WaitReadable
              break
            end
          end
        end
      end

      unless @buffer.empty?
        used = 0
        StringIO.new(@buffer).each_line do |line|
          if line[-1] == "\n"
            process_command(line.chomp)
            used += line.size
          else
            break
          end
        end
        @buffer = @buffer[used...-1]
      end
    end
  end

  def run
    begin
      loop do
        # This greatly reduces performance, but works around
        # ncurses using an optimization that is incorrect, which
        # leads to the scrollbar background bleeding into the list.
        process_buffer
        while (ch = Ncurses.getch) != -1
          list.handle_input(ch)
        end
        list.render
        Ncurses.redrawwin(list.window)
        Ncurses.refresh
      end
    ensure
      deinitialize
    end
  end
end

[$stdin, $stdout].each do |io|
  io.sync = true
  io.reopen('/dev/null') if io.tty?
end

begin
  ClientTerminal.new.run
rescue Interrupt
  $stdout.puts "interrupt"
  $stdout.flush
rescue SystemCallError => e
  $stderr.puts "#{$0}: #{e.message}"
  exit 1
end
