#!/usr/bin/env ruby

require 'curses'
require 'socket'
require 'optparse'

$pair = 1

def alloc_colorpair(fg, bg)
  $pair += 1
  Curses.init_pair($pair, fg, bg)
  $pair
end

def key_name(v)
  m = {
    10  => 'enter',
    260 => 'left',
    261 => 'right',
    127 => 'backspace',
    330 => 'delete',
    ' ' => 'space',
  }
  m[v] || v
end

class Scrollbar
  DOWN_ARROW = '▼'
  UP_ARROW   = '▲'
  BACKGROUND = ' '
  THUMB      = ' '

  attr_reader :list

  def width
    1
  end

  def initialize(list)
    @list = list
    @color_background = 4
    Curses.init_pair(@color_background, Curses::COLOR_BLACK, Curses::COLOR_BLACK)

    @color_thumb = 5
    Curses.init_pair(@color_thumb, Curses::COLOR_WHITE, Curses::COLOR_WHITE)

    @color_enabled_arrow = 6
    Curses.init_pair(@color_enabled_arrow, Curses::COLOR_WHITE, Curses::COLOR_BLACK)
    @color_disabled_arrow = @color_enabled_arrow
  end

  def render
    return if list.values.size <= window.maxy

    window.color_set(can_scroll_up? ? @color_enabled_arrow : @color_disabled_arrow)
    window.setpos(0, window.maxx - 1)
    window.addstr(UP_ARROW)

    window.color_set(can_scroll_down? ? @color_enabled_arrow : @color_disabled_arrow)
    window.setpos(window.maxy - 1, window.maxx - 1)
    window.addstr(DOWN_ARROW)

    window.color_set(@color_background)
    (1...window.maxy-1).each do |y|
      window.setpos(y, window.maxx - 1)
      window.addstr(BACKGROUND)
    end


    # Ref: http://csdgn.org/inform/scrollbar-mechanics
    contentSize = list.values.size.to_f
    windowSize = window.maxy.to_f
    trackSize = windowSize - 2
    windowContentRatio = windowSize / contentSize
    gripSize = trackSize * windowContentRatio

    minimalGripSize = 1.0
    if(gripSize < minimalGripSize)
      gripSize = minimalGripSize
    end

    windowScrollAreaSize = contentSize - windowSize
    windowPosition = list.offset.to_f
    windowPositionRatio = windowPosition / windowScrollAreaSize

    trackScrollAreaSize = trackSize - gripSize
    gripPositionOnTrack = trackScrollAreaSize * windowPositionRatio


    st = 1 + gripPositionOnTrack.floor.to_i
    e = (st + gripSize.ceil).to_i

    st = 1 if st < 1
    e = window.maxy - 1 if e > window.maxy - 1

    @last ||= []
    if @last != [st,e]
      list.socket.puts [st, e].inspect
      @last = [st, e]
    end

    window.color_set(@color_thumb)
    (st...e).each do |y|
      window.setpos(y, window.maxx - 1)
      window.addstr(THUMB)
    end
  end

  def window
    list.window
  end

  def can_scroll_up?
    list.offset > 0
  end

  def can_scroll_down?
    list.values.size > list.offset + window.maxy
  end
end

class List
  INDICATOR    = ' ➤ '
  NO_INDICATOR = '   '

  attr_reader   :window
  attr_reader   :socket
  attr_accessor :values
  attr_reader   :selected
  attr_reader   :offset

  attr_reader :color_default
  attr_reader :color_selected
  attr_reader :scrollbar

  def initialize(window, socket:)
    @window = window
    @values = []
    @selected = 0
    @offset = 0
    @socket = socket
    @dirty = true
    @locked = false

    @color_default  = 0
    @color_selected = 1
    Curses.init_pair(@color_default, Curses::COLOR_WHITE, Curses::COLOR_BLACK)
    Curses.init_pair(@color_selected, Curses::COLOR_BLACK, Curses::COLOR_WHITE)

    @scrollbar = Scrollbar.new(self)
  end

  def lock
    @locked = true
    yield
  ensure
    @locked = false
    render
  end

  def locked?
    @locked
  end

  def dirty!
    @dirty = true
  end

  def dirty?
    !! @dirty
  end

  def offset=(v)
    dirty! if v != @offset
    @offset = v
  end

  attr_reader :selected
  def selected=(v)
    current = @selected

    v = 0 if v < 0
    v = values.size - 1 if v >= values.size
    @selected = v

    if @selected >= offset + window.maxy
      self.offset = v - window.maxy + 1
    elsif @selected < offset
      self.offset = @selected
    end

    if current != selected
      dirty!
      selection_changed
    end
    @selected
  end

  def handle_input(value)
    case value
      when Curses::KEY_UP
        self.selected -= 1
      when Curses::KEY_DOWN
        self.selected += 1
      else
        key_pressed(value)
    end
  end

  def selection_changed
    socket.puts "select #{selected} #{values[selected]}"
  end

  def key_pressed(k)
    socket.puts "keypress #{key_name(k)} #{selected} #{values[selected]}"
  end

  def dirty!(v = true)
    @dirty = v
  end

  def render()
    return if locked?
    return unless dirty?
    dirty!(false)

    (0...window.maxy).each do |i|
      item_index = @offset + i
      window.setpos(i, 0)
      indicator = ' '
      if item_index >= values.size
        window.color_set(@color_default)
        window.addstr(' ' * window.maxx)
        next
      end

      if item_index == selected
        window.color_set(@color_selected)
        indicator = INDICATOR
      else
        window.color_set(@color_default)
        indicator = NO_INDICATOR
      end

      string = indicator + (values[item_index] || '')
      fixed_len = window.maxx - scrollbar.width
      if string.size < fixed_len
        string += (' ' * (fixed_len - string.size))
      elsif string.size > fixed_len
        string = string[0...fixed_len]
      end
      window.addstr(string)
    end

    scrollbar.render
    window.refresh
  end
end

class ClientTerminal
  attr_accessor :list
  def initialize(socket)
    Curses.init_screen
    Curses.start_color
    Curses.use_default_colors
    Curses.cbreak
    Curses.stdscr.scrollok(false)
    Curses.stdscr.keypad = true
    Curses.curs_set(0)
    Curses.noecho
    Curses.timeout = 25

    @socket = socket
    @list = List.new(Curses.stdscr, socket: @socket)
    @list.values = []
    @buffer = ''
  end

  def process_command(cmd)
    list.values.push(cmd)
    list.dirty!
    list.render
  end

  def process_buffer
    @list.lock do
      res = IO.select([@socket], [], [], 0.025)
      if res && (readers = res[0]) && (rd = readers[0])
        begin
          @buffer << rd.read_nonblock(512)
        rescue IO::WaitReadable
          # pass
        end
      end

      used = 0
      StringIO.new(@buffer).each_line do |line|
        if line[-1] == "\n"
          process_command(line.chomp)
          used += line.size
        else
          break
        end
      end
      @buffer = @buffer[used...-1]
    end
  end

  def run
    begin
      loop do
        process_buffer
        list.render
        if (ch = Curses.getch)
          list.handle_input(ch)
        end
        Curses.refresh
      end
    ensure
      Curses.close_screen
    end
  end
end


STDIN.sync = true
STDOUT.sync = true

com = UNIXSocket.pair
com.map {|c| c.sync=true }

child = fork do
  # Ruby curses doens't have newterm, so we have to reopen
  # stdin/stdout to a TTY and communicate with the parent
  # over a pipe
  STDIN.reopen('/dev/tty', 'r')
  STDOUT.reopen('/dev/tty', 'w')

  gui = ClientTerminal.new(com[1])
  begin
    gui.run
  rescue Interrupt
  end
  exit 0
end

if STDOUT.tty?
  STDOUT.reopen('/dev/null', 'w')
end
STDOUT.sync = true

if STDIN.tty?
  STDIN.reopen('/dev/null', 'r')
end
STDIN.sync = true

gui_socket = com[0]
lines = {
  $stdin    => nil,
  gui_socket => nil
}

bufs = {
  $stdin => '',
  gui_socket => ''
}

handles = [$stdin, gui_socket]

@gui_socket = gui_socket
def dispatch_input_command(command)
  @gui_socket.puts command
end

def dispatch_line(fd, line)
  if fd == $stdin
    dispatch_input_command(line)
  else # coming from the subprocess
    puts line
  end
end


loop do
  res = IO.select(handles, [], [], 1.0)

  if res && (rd = res[0])
    rd.each do |fd|
      loop do
        begin
          bytes = fd.read_nonblock(512)
          bufs[fd] << bytes
        rescue EOFError
          handles.delete(fd)
          break
        rescue IO::WaitReadable
          break
        end
      end
    end
  end

  bufs.each do |fd, str|
    used = 0
    sio = StringIO.new(str)
    sio.each_line do |line|
      if line[-1] == "\n"
        used += line.size
        dispatch_line(fd, line.chomp)
      else
        break
      end
    end
    bufs[fd] = str[used...-1]
  end
  bufs.reject! {|fd, v| fd.eof? }
end
